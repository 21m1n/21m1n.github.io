<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Asyncio in Python | De Omnibus Dubitandum</title>
<meta name="keywords" content="python, concurrency">
<meta name="description" content="With the advent of large language models (LLMs), asynchronous programming has become a critical skill in AI application development. When working with these computationally intensive models, developers face two key challenges: LLMs are typically served via network endpoints, introducing significant latency that can severely impact application responsiveness. This is where asynchronous programming shine.
Unlike traditional synchronous programming, where operations execute sequentially and block until completion, asynchronous programming allows applications to continue processing CPU-bound operations while waiting for I/O-bound responses in the background. This approach not only maximuizes computational resource utilization but also dramatically improves user experiences by keep applications responsive, even when interacting with resource-intensive services like LLMs.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/asyncio/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.aceab174d3ce85ab394ce78afe91e41cb9b9270dc41057d20de8519fc94c1f7b.css" integrity="sha256-rOqxdNPOhas5TOeK/pHkHLm5Jw3EEFfSDehRn8lMH3s=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/asyncio/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Spectral+SC:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="De Omnibus Dubitandum (Alt + H)">De Omnibus Dubitandum</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Asyncio in Python
    </h1>
    <div class="post-meta"><span title='2025-04-06 07:19:42 +0800 +08'>April 6, 2025</span>&nbsp;·&nbsp;23 min&nbsp;·&nbsp;4747 words

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#understanding-concurrency-paradigms" aria-label="Understanding Concurrency Paradigms">Understanding Concurrency Paradigms</a></li>
                <li>
                    <a href="#synchronous-vs-asynchronous" aria-label="Synchronous vs. Asynchronous">Synchronous vs. Asynchronous</a></li>
                <li>
                    <a href="#evolution-of-asyncio-in-python" aria-label="Evolution of AsyncIO in Python">Evolution of AsyncIO in Python</a><ul>
                        
                <li>
                    <a href="#running-blocking-functions-in-an-asynchronous-context" aria-label="Running blocking functions in an asynchronous context">Running blocking functions in an asynchronous context</a></li>
                <li>
                    <a href="#progression-of-pythons-async-capabilities" aria-label="Progression of Python&rsquo;s Async Capabilities">Progression of Python&rsquo;s Async Capabilities</a></li></ul>
                </li>
                <li>
                    <a href="#core-asyncio-components" aria-label="Core AsyncIO components">Core AsyncIO components</a><ul>
                        
                <li>
                    <a href="#coroutines" aria-label="Coroutines">Coroutines</a></li>
                <li>
                    <a href="#event-loop" aria-label="Event Loop">Event Loop</a></li>
                <li>
                    <a href="#tasks-and-futures" aria-label="Tasks and Futures">Tasks and Futures</a><ul>
                        
                <li>
                    <a href="#ensure_future-vs-create_task" aria-label="ensure_future() vs. create_task()">ensure_future() vs. create_task()</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#beyond-the-basics-advanced-asyncio-patterns" aria-label="Beyond the Basics: Advanced AsyncIO Patterns">Beyond the Basics: Advanced AsyncIO Patterns</a></li>
                <li>
                    <a href="#async-context-management-async-with" aria-label="Async Context Management: async with">Async Context Management: async with</a><ul>
                        
                <li>
                    <a href="#simplifying-context-management-with-decorators" aria-label="Simplifying Context Management with Decorators">Simplifying Context Management with Decorators</a></li>
                <li>
                    <a href="#bridging-synchronous-and-asynchronous-worlds" aria-label="Bridging Synchronous and Asynchronous Worlds">Bridging Synchronous and Asynchronous Worlds</a></li></ul>
                </li>
                <li>
                    <a href="#working-with-streams-async-iteration-and-comprehension" aria-label="Working with Streams: Async Iteration and Comprehension">Working with Streams: Async Iteration and Comprehension</a></li>
                <li>
                    <a href="#ensuring-reliability-shutdown-gracefully" aria-label="Ensuring Reliability: Shutdown gracefully">Ensuring Reliability: Shutdown gracefully</a><ul>
                        
                <li>
                    <a href="#shutdown-strategies-and-best-practices" aria-label="Shutdown Strategies and Best Practices">Shutdown Strategies and Best Practices</a></li></ul>
                </li>
                <li>
                    <a href="#advanced-asyncio-modules" aria-label="Advanced AsyncIO Modules">Advanced AsyncIO Modules</a></li>
                <li>
                    <a href="#writing-tests-for-asyncio-code-with-pytest" aria-label="Writing Tests for AsyncIO Code with pytest">Writing Tests for AsyncIO Code with pytest</a><ul>
                        
                <li>
                    <a href="#mocking-asynchronous-functions" aria-label="Mocking Asynchronous Functions">Mocking Asynchronous Functions</a></li>
                <li>
                    <a href="#test-asynchronous-context-managers" aria-label="Test Asynchronous Context Managers">Test Asynchronous Context Managers</a></li></ul>
                </li>
                <li>
                    <a href="#ecosystem-integrations" aria-label="Ecosystem Integrations">Ecosystem Integrations</a></li>
                <li>
                    <a href="#working-with-http-requests-aiohttp" aria-label="Working with HTTP Requests: aiohttp">Working with HTTP Requests: aiohttp</a></li>
                <li>
                    <a href="#asynchronous-file-operations-aiofiles" aria-label="Asynchronous File Operations: aiofiles">Asynchronous File Operations: aiofiles</a></li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>With the advent of large language models (LLMs), asynchronous programming has become a critical skill in AI application development. When working with these computationally intensive models, developers face two key challenges: LLMs are typically served via network endpoints, introducing significant latency that can severely impact application responsiveness. This is where asynchronous programming shine.</p>
<p>Unlike traditional synchronous programming, where operations execute sequentially and block until completion, asynchronous programming allows applications to continue processing CPU-bound operations while waiting for I/O-bound responses in the background. This approach not only maximuizes computational resource utilization but also dramatically improves user experiences by keep applications responsive, even when interacting with resource-intensive services like LLMs.</p>
<p>For developers working with LLM-powered applications, mastering asynchronous programming patterns has become essential for building scalable, responsive systems. In this article, we will explore Python&rsquo;s asyncIO framework: how it evolved, its core components, practical implementations, and why it&rsquo;s particularly valuable for AI application development.</p>
<h2 id="understanding-concurrency-paradigms">Understanding Concurrency Paradigms<a hidden class="anchor" aria-hidden="true" href="#understanding-concurrency-paradigms">#</a></h2>
<p>Before diving into asyncIO, let&rsquo;s clarify the fundamental concepts that underpin different approaches to concurrent programming. These distinctions are crucial for choosing the right approach for your specific use case.</p>
<p><strong>Parallelism vs. Concurrency</strong></p>
<ul>
<li><strong>Parallelism</strong> refers to executing multiple computations simultaneously,typically across multiple CPU cores. It&rsquo;s like <em>having multiple chefs working independently in different kitchen stations</em>.</li>
<li><strong>Concurrency</strong> refers to managing multiple tasks with overlapping time periods. It doesn&rsquo;t necessarily mean tasks execute at the exact same time. This is like <em>a single chef rapidly switching between multiple dishes on the stove, ensuring none burns while others are cooking</em>.</li>
</ul>
<p><strong>Multiprocessing vs. Multithreading vs. Asynchronous programming</strong></p>
<ul>
<li><strong>Multiprocessing</strong> involves spawning multiple python processors, each process operates independently with its own python interpreter and memory space. This approach achieves true parallelism but requires more system resources and introduces communication overhead between processes.</li>
<li><strong>Multithreading</strong> allows multiple threads within a single process to run concurrently. These threads share the same memory space, enabling efficient communication but may lead to race conditions or deadlocks if not handled properly. In Python, the Global Interpreter Lock (GIL) limits the benefits of multithreading for CPU-bound tasks.</li>
<li><strong>Asynchronous programming</strong> uses a single-threaded, cooperative multitasking approach where tasks voluntarily yield control when waiting for I/O operations. This approach excels at handling I/O-bound operations like network requests or database queries without the overhead of multiple threads or processes.</li>
</ul>
<h2 id="synchronous-vs-asynchronous">Synchronous vs. Asynchronous<a hidden class="anchor" aria-hidden="true" href="#synchronous-vs-asynchronous">#</a></h2>
<p>To understand why asynchronous programming is so valuable for LLM applications, let&rsquo;s compare how synchronous and asynchronous approaches handle multiple operations. The difference becomes particularly significant when dealing with I/O-bound tasks like API calls to LLM services:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#6272a4"># simple benchmark comparing sync vs async approaches</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> asyncio
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> time
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># synchronous approach</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">def</span> <span style="color:#50fa7b">sync_fetch</span>(url):
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># simulate network delay</span>
</span></span><span style="display:flex;"><span>    time<span style="color:#ff79c6">.</span>sleep(<span style="color:#bd93f9">1</span>)  
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;Data from </span><span style="color:#f1fa8c">{</span>url<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">def</span> <span style="color:#50fa7b">sync_main</span>():
</span></span><span style="display:flex;"><span>    start <span style="color:#ff79c6">=</span> time<span style="color:#ff79c6">.</span>time()
</span></span><span style="display:flex;"><span>    results <span style="color:#ff79c6">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># process URLs sequentially</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">in</span> <span style="color:#8be9fd;font-style:italic">range</span>(<span style="color:#bd93f9">5</span>):
</span></span><span style="display:flex;"><span>        results<span style="color:#ff79c6">.</span>append(sync_fetch(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;url_</span><span style="color:#f1fa8c">{</span>i<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">&#34;</span>))
</span></span><span style="display:flex;"><span>    end <span style="color:#ff79c6">=</span> time<span style="color:#ff79c6">.</span>time()
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;Sync approach took </span><span style="color:#f1fa8c">{</span>end<span style="color:#ff79c6">-</span>start<span style="color:#f1fa8c">:</span><span style="color:#f1fa8c">.2f</span><span style="color:#f1fa8c">}</span><span style="color:#f1fa8c"> seconds&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> results
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># asynchronous approach</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">async_fetch</span>(url):
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># Simulate network delay without blocking</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">await</span> asyncio<span style="color:#ff79c6">.</span>sleep(<span style="color:#bd93f9">1</span>)  
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;Data from </span><span style="color:#f1fa8c">{</span>url<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">async_main</span>():
</span></span><span style="display:flex;"><span>    start <span style="color:#ff79c6">=</span> time<span style="color:#ff79c6">.</span>time()
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># initiate all requests concurrently</span>
</span></span><span style="display:flex;"><span>    tasks <span style="color:#ff79c6">=</span> [async_fetch(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;url_</span><span style="color:#f1fa8c">{</span>i<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">&#34;</span>) <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">in</span> <span style="color:#8be9fd;font-style:italic">range</span>(<span style="color:#bd93f9">5</span>)]
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># Wait for all to complete</span>
</span></span><span style="display:flex;"><span>    results <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">await</span> asyncio<span style="color:#ff79c6">.</span>gather(<span style="color:#ff79c6">*</span>tasks)
</span></span><span style="display:flex;"><span>    end <span style="color:#ff79c6">=</span> time<span style="color:#ff79c6">.</span>time()
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;Async approach took </span><span style="color:#f1fa8c">{</span>end<span style="color:#ff79c6">-</span>start<span style="color:#f1fa8c">:</span><span style="color:#f1fa8c">.2f</span><span style="color:#f1fa8c">}</span><span style="color:#f1fa8c"> seconds&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> results
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># Run both approaches</span>
</span></span><span style="display:flex;"><span>sync_results <span style="color:#ff79c6">=</span> sync_main()  <span style="color:#6272a4"># Takes ~5 seconds</span>
</span></span><span style="display:flex;"><span>async_results <span style="color:#ff79c6">=</span> asyncio<span style="color:#ff79c6">.</span>run(async_main())  <span style="color:#6272a4"># Takes ~1 second</span>
</span></span></code></pre></div><p>This example demonstrates the dramatic differences between two approaches. The synchronous version processes requests sequentially, waiting for each to complete before starting the next. With five one-second operations, it takes roughly give seconds to complete. The asynchronous approach, however, initiates all requests concurrently and awaits their completion in parallel completing in just over one second.</p>
<p>This performance gap widens further with more operations or longer wait times, highlighting why asynchronous programming is essential when building applications that make multiple calls to LLM services, databases, or other I/O-bound resources.</p>
<h2 id="evolution-of-asyncio-in-python">Evolution of AsyncIO in Python<a hidden class="anchor" aria-hidden="true" href="#evolution-of-asyncio-in-python">#</a></h2>
<p>Before the introduction of AsyncIO in Python 3.4, asynchronous programming was often simulated using generators combined with callbacks or frameworks (like <code>tornado</code> or <code>Twisted</code>). Generators allowed developers to write asynchronous code in a way that resembled synchronous code, using <code>yield</code> keyword to pause and resume execution:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#6272a4"># example of using generators simulating asynchronous programming</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> time 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">def</span> <span style="color:#50fa7b">async_task</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">yield</span> <span style="color:#f1fa8c">&#34;start task&#34;</span> 
</span></span><span style="display:flex;"><span>    time<span style="color:#ff79c6">.</span>sleep(<span style="color:#bd93f9">1</span>) <span style="color:#6272a4"># simulate blocking I/O</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">yield</span> <span style="color:#f1fa8c">&#34;task completed&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">def</span> <span style="color:#50fa7b">run</span>(generator):
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># a simple scheduler to run the generator</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># it iterates over the generator, simulating a </span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># scheduler that drives the asynchronous execution</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> step <span style="color:#ff79c6">in</span> generator:
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">print</span>(step)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>task <span style="color:#ff79c6">=</span> async_task()
</span></span><span style="display:flex;"><span>run(task)
</span></span></code></pre></div><p>The code above mimics asynchronous programming by breaking tasks into smaller steps and executing them <strong>sequentially</strong>. However, it doesn&rsquo;t provide the true concurrency. To do that, developers would need to use generators in combination with callbacks, leveraging exceptions like <code>StopIteration</code> to signal completion:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff79c6">import</span> time
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">def</span> <span style="color:#50fa7b">async_sleeping</span>(duration):
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">yield</span> <span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;sleeping for </span><span style="color:#f1fa8c">{</span>duration<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c"> seconds...&#34;</span>
</span></span><span style="display:flex;"><span>    time<span style="color:#ff79c6">.</span>sleep(duration)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">yield</span> <span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;slept for </span><span style="color:#f1fa8c">{</span>duration<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c"> seconds!&#34;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">def</span> <span style="color:#50fa7b">run</span>(generator):
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">try</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">while</span> <span style="color:#ff79c6">True</span>:
</span></span><span style="display:flex;"><span>            step <span style="color:#ff79c6">=</span> <span style="color:#8be9fd;font-style:italic">next</span>(generator)
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">print</span>(step)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">except</span> StopIteration:
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">pass</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>task <span style="color:#ff79c6">=</span> async_sleeping(<span style="color:#bd93f9">2</span>)
</span></span><span style="display:flex;"><span>run(task)
</span></span></code></pre></div><p>When a generator exhausted its <code>yield</code> statements, it raised <code>StopIteration</code>, signaling completion to the event loop. This allowed the loop to clean up resources or schedule new tasks. But still, generators are not true asynchronous programming, because generators can&rsquo;t handle true non-blocking I/O operations efficiently, and developers had to implement event loops and schedulers manually, leading to error-prone code.</p>
<p>Python 3.4 introduced the <code>asyncio</code> module, making a significant milestone in Python&rsquo;s asynchronous capabilities. This dedicated framework provided standardized tool for asynchronous programming, including event loops, coroutines, futures and tasks. However, the early syntax still relied on generators and decorators, and working with the event loop required considerable boilerplate code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#6272a4"># example from the book: </span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> asyncio
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> time
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">main</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">{</span>time<span style="color:#ff79c6">.</span>ctime()<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c"> hello!&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">await</span> asyncio<span style="color:#ff79c6">.</span>sleep(<span style="color:#bd93f9">1.0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">{</span>time<span style="color:#ff79c6">.</span>ctime()<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c"> goodbye!&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># a loop instance is required to run coroutines </span>
</span></span><span style="display:flex;"><span>loop <span style="color:#ff79c6">=</span> asyncio<span style="color:#ff79c6">.</span>get_event_loop()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># OPTIONAL:</span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># use create_task() to schedule the coroutine to be run on the loop </span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># the returned object can be used to monitor the status of the task </span>
</span></span><span style="display:flex;"><span>task <span style="color:#ff79c6">=</span> loop<span style="color:#ff79c6">.</span>create_task(main())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># this call blocks the current thread and keep the loop running </span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># only until the given coroutine completes </span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># other tasks scheduled on the loop will also run while the loop is running.</span>
</span></span><span style="display:flex;"><span>results <span style="color:#ff79c6">=</span> loop<span style="color:#ff79c6">.</span>run_until_complete(task)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># gather the still-pending tasks, cancel them</span>
</span></span><span style="display:flex;"><span>pending <span style="color:#ff79c6">=</span> asyncio<span style="color:#ff79c6">.</span>all_tasks(loop<span style="color:#ff79c6">=</span>loop)
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">for</span> task <span style="color:#ff79c6">in</span> pending:
</span></span><span style="display:flex;"><span>    task<span style="color:#ff79c6">.</span>cancel()
</span></span><span style="display:flex;"><span>group <span style="color:#ff79c6">=</span> asyncio<span style="color:#ff79c6">.</span>gather(<span style="color:#ff79c6">*</span>pending, return_exceptions<span style="color:#ff79c6">=</span><span style="color:#ff79c6">True</span>)
</span></span><span style="display:flex;"><span>loop<span style="color:#ff79c6">.</span>run_until_complete(group)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># to be called on a stopped loop</span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># it will clear all the queues and shut down the executor</span>
</span></span><span style="display:flex;"><span>loop<span style="color:#ff79c6">.</span>close()
</span></span></code></pre></div><p>As shown above, developers had to manually create, manage and close the event loop using <code>get_event_loop</code>, <code>run_until_complete</code> and <code>loop.close()</code>, leading to verbose code even for simple asynchronous operations. This complexity was significantly reduced with Python 3.7&rsquo;s introduction of <code>asyncio.run()</code>, which handles all the event loop management automatically:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff79c6">import</span> asyncio
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> time
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">main</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">{</span>time<span style="color:#ff79c6">.</span>ctime()<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c"> hello!&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">await</span> asyncio<span style="color:#ff79c6">.</span>sleep(<span style="color:#bd93f9">1.0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">{</span>time<span style="color:#ff79c6">.</span>ctime()<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c"> goodbye!&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># Python 3.7+</span>
</span></span><span style="display:flex;"><span>results <span style="color:#ff79c6">=</span> asyncio<span style="color:#ff79c6">.</span>run(main())
</span></span></code></pre></div><h3 id="running-blocking-functions-in-an-asynchronous-context">Running blocking functions in an asynchronous context<a hidden class="anchor" aria-hidden="true" href="#running-blocking-functions-in-an-asynchronous-context">#</a></h3>
<p>One common challenge when working with asyncIO integrating existing synchronous, blocking code into an asynchronous application. This is particularly relevant when working with LLMs, as many existing Python libraries may not have sync-native APIs.</p>
<p>When faced with a blocking function that would halt your event loop, you need to offload it to a separate thread or process. Prior to Pytnon 3.9, this was typically done using <code>asyncio.run_in_executor()</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff79c6">import</span> time 
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> asyncio 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">main</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">{</span>time<span style="color:#ff79c6">.</span>ctime()<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c"> hello!&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">await</span> asyncio<span style="color:#ff79c6">.</span>sleep(<span style="color:#bd93f9">1.0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">{</span>time<span style="color:#ff79c6">.</span>ctime()<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c"> goodbye!&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">def</span> <span style="color:#50fa7b">blocking</span>():
</span></span><span style="display:flex;"><span>    time<span style="color:#ff79c6">.</span>sleep(<span style="color:#bd93f9">0.5</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">{</span>time<span style="color:#ff79c6">.</span>ctime()<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c"> Hello from a thread!&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loop <span style="color:#ff79c6">=</span> asyncio<span style="color:#ff79c6">.</span>get_event_loop()
</span></span><span style="display:flex;"><span>task <span style="color:#ff79c6">=</span> loop<span style="color:#ff79c6">.</span>create_task(main())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># run the blocking function in the default executor</span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># note that the first argument must be `None` to use the default executor.</span>
</span></span><span style="display:flex;"><span>loop<span style="color:#ff79c6">.</span>run_in_executor(<span style="color:#ff79c6">None</span>, blocking)
</span></span><span style="display:flex;"><span>loop<span style="color:#ff79c6">.</span>run_until_complete(task)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>pending <span style="color:#ff79c6">=</span> asyncio<span style="color:#ff79c6">.</span>all_tasks(loop<span style="color:#ff79c6">=</span>loop)
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">for</span> task <span style="color:#ff79c6">in</span> pending:
</span></span><span style="display:flex;"><span>    task<span style="color:#ff79c6">.</span>cancel()
</span></span><span style="display:flex;"><span>group <span style="color:#ff79c6">=</span> asyncio<span style="color:#ff79c6">.</span>gather(<span style="color:#ff79c6">*</span>pending, return_exceptions<span style="color:#ff79c6">=</span><span style="color:#ff79c6">True</span>)
</span></span><span style="display:flex;"><span>loop<span style="color:#ff79c6">.</span>run_until_complete(group)
</span></span><span style="display:flex;"><span>loop<span style="color:#ff79c6">.</span>close()
</span></span></code></pre></div><p><code>asyncio.run_in_executor()</code> doesn&rsquo;t block the main thread, it only schedules the executor task to run. The executor task begins executing only after <code>run_until_complete()</code> is called, allowing the event loop to manage the execution alongside other async tasks.</p>
<p><strong>Note:</strong> Python 3.9 introduced the cleaner and more intuitive <code>asyncio.to_thread()</code> function, allowing the preceding example to be rewritten more elegantly:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff79c6">import</span> time 
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> asyncio 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">main</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">{</span>time<span style="color:#ff79c6">.</span>ctime()<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c"> hello!&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">await</span> asyncio<span style="color:#ff79c6">.</span>sleep(<span style="color:#bd93f9">1.0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">{</span>time<span style="color:#ff79c6">.</span>ctime()<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c"> goodbye!&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">def</span> <span style="color:#50fa7b">blocking</span>():
</span></span><span style="display:flex;"><span>    time<span style="color:#ff79c6">.</span>sleep(<span style="color:#bd93f9">0.5</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;</span><span style="color:#f1fa8c">{</span>time<span style="color:#ff79c6">.</span>ctime()<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c"> Hello from a thread!&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">run</span>():
</span></span><span style="display:flex;"><span>    task <span style="color:#ff79c6">=</span> asyncio<span style="color:#ff79c6">.</span>create_task(main())
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">await</span> asyncio<span style="color:#ff79c6">.</span>to_thread(blocking)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">await</span> task
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>asyncio<span style="color:#ff79c6">.</span>run(run())
</span></span></code></pre></div><h3 id="progression-of-pythons-async-capabilities">Progression of Python&rsquo;s Async Capabilities<a hidden class="anchor" aria-hidden="true" href="#progression-of-pythons-async-capabilities">#</a></h3>
<p>Python&rsquo;s asynchronous programming features have evolved significantly over the past decade, with each version bringing important improvements to make async code more powerful, readable, and maintainable:</p>
<ul>
<li>Python 3.4 (2014): Introduction of AsyncIO module with <code>@asyncio.coroutine</code> decorator and <code>yield</code> from syntax</li>
<li>Python 3.5 (2015): Native <code>async/await</code> syntax added, making async code more readable</li>
<li>Python 3.6 (2016): Asynchronous generators and comprehensions</li>
<li>Python 3.7 (2018): <code>asyncio.run()</code>, better debugging, performance improvements</li>
<li>Python 3.8 (2019): <code>asyncio.create_task()</code> becomes the standard API, <code>asyncio.get_running_loop()</code> introduced</li>
<li>Python 3.9 (2020): Improved error messages, <code>asyncio.to_thread()</code> added</li>
<li>Python 3.10 (2021): Structural pattern matching for async results, <code>asyncio.TaskGroup</code></li>
<li>Python 3.11 (2022): Task exception groups, performance optimizations</li>
<li>Python 3.12 (2023): Enhanced cancellation features, improved reliability</li>
<li>Python 3.13 (2024): Improved task scheduling efficiency and memory usage optimization</li>
</ul>
<h2 id="core-asyncio-components">Core AsyncIO components<a hidden class="anchor" aria-hidden="true" href="#core-asyncio-components">#</a></h2>
<p>At its core, asyncio is built on three fundamental concepts: <strong>coroutines</strong>, <strong>the event loop</strong>, and <strong>tasks</strong>. Think of them as the trinity of async programming in Python.</p>
<h3 id="coroutines">Coroutines<a hidden class="anchor" aria-hidden="true" href="#coroutines">#</a></h3>
<p>Coroutines are the fundamental building blocks of AsyncIO, defined using <code>async def</code> syntax introduced in Python 3.5. They represent functions that can be paused and resumed, allowing other coroutines to run while waiting for I/O operations. This cooperative multitasking approach is what enables efficient concurrency without the overhead of multiple threads.</p>
<p>To understand how coroutines work, let&rsquo;s first look at a simple example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#6272a4"># this is a coroutine </span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">fetch_data</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">await</span> asyncio<span style="color:#ff79c6">.</span>sleep(<span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#f1fa8c">&#34;Data fetched&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># type(fetch_data) -&gt; function </span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># f = fetch_data(), type(f) -&gt; coroutine</span>
</span></span></code></pre></div><p>Under the hood, a coroutine is triggered by sending it a <code>None</code>; and when it returns, a <code>StopIteration</code> exception is raised. While these can be marked as the beginning and the end of a coroutine, <code>throw</code> can be used to inject exceptions into a coroutine:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>coro <span style="color:#ff79c6">=</span> f()
</span></span><span style="display:flex;"><span>coro<span style="color:#ff79c6">.</span>send(<span style="color:#ff79c6">None</span>)
</span></span><span style="display:flex;"><span>coro<span style="color:#ff79c6">.</span>throw(Exception, <span style="color:#f1fa8c">&#34;blah&#34;</span>)
</span></span></code></pre></div><p>Or cancel a task:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff79c6">import</span> asyncio 
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">f</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">try</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">while</span> <span style="color:#ff79c6">True</span>: <span style="color:#ff79c6">await</span> asyncio<span style="color:#ff79c6">.</span>sleep(<span style="color:#bd93f9">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">except</span> asyncio<span style="color:#ff79c6">.</span>CancelledError:
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">&#34;I was cancelled&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">else</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">111</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>coro <span style="color:#ff79c6">=</span> f()
</span></span><span style="display:flex;"><span>coro<span style="color:#ff79c6">.</span>send(<span style="color:#ff79c6">None</span>)
</span></span><span style="display:flex;"><span>coro<span style="color:#ff79c6">.</span>send(<span style="color:#ff79c6">None</span>)
</span></span><span style="display:flex;"><span>coro<span style="color:#ff79c6">.</span>throw(asyncio<span style="color:#ff79c6">.</span>CancelledError)
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># i was cancelled!</span>
</span></span></code></pre></div><p>Coroutines bear a structural resemblance to generators, which is why generators were initially used to simulate coroutines before the introduction of native <code>async/await</code> syntax. Developers would use generators with special decorators (like <code>@asyncio.coroutine</code>) to approximate coroutine behavior.</p>
<p>What fundamentally distinguishes a coroutine from a regular function or generator is its execution model. When called, a <strong>coroutine doesn&rsquo;t execute immediately</strong> but instead returns a coroutine object - essentially a promise or placeholder for a future result. This deferred execution is what enables the event loop to orchestrate multiple coroutines efficiently.</p>
<h3 id="event-loop">Event Loop<a hidden class="anchor" aria-hidden="true" href="#event-loop">#</a></h3>
<p>The event loop coordinates the execution of coroutines. It manages the switching between different coroutines, catches exceptions, listens to sockets and file descriptors for events, and ensures that the application remains responsive while handling multiple operations concurrently.</p>
<p>For most applications since Python 3.7, <code>asyncio.run(coro)</code> is the recommended approach, as it manages the event loop for you. This high-level function creates an event loop, runs the coroutine until it completes, and then closes the loop, handling many of the details that previously required manual implementation.</p>
<p>The event loop in AsyncIO handles all of the switching between coroutines, as well as catching the exceptions, listening to sockets and file descriptors for events.</p>
<p>While modern Python asyncIO code often uses high-level APIs that manage the event loop automatically, sometimes you need direct access to the loop itself - for example, when scheduling custom callbacks, working with low-level transports, or integrating with non-asyncio code. Python provides several ways to access the current event loop, each appropriate for different scenarios:</p>
<ul>
<li><code>asyncio.get_running_loop()</code> (<em>recommended</em>): callable from inside the context of a coroutine</li>
<li><code>asyncio.get_event_loop()</code>: only works in the same thread; can implicitly create new event loop if none exists</li>
</ul>
<h3 id="tasks-and-futures">Tasks and Futures<a hidden class="anchor" aria-hidden="true" href="#tasks-and-futures">#</a></h3>
<p>Tasks and Futures are closely related concepts that represent different aspects of asynchronous execution:</p>
<p>A <strong>Task</strong> is a wrapper around a coroutine that schedules it for execution on the event loop. You create a Task by passing a coroutine to functions like <code>loop.create_task(coro)</code> or the newer <code>asyncio.create_task(coro)</code>. Once created, a Task actively executes its coroutine when the event loop runs, without requiring additional action from the developer.</p>
<p>A <strong>Future</strong>, on the other hand, is a lower-level construct that doesn&rsquo;t run any code itself. Futures serve as placeholders for results that will be available in the future. They provide a way to track the status of an operation (pending, completed, or failed) and access its result when available.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff79c6">import</span> asyncio 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">main</span>(f: asyncio<span style="color:#ff79c6">.</span>Future):
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">await</span> asyncio<span style="color:#ff79c6">.</span>sleep(<span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>    f<span style="color:#ff79c6">.</span>set_result(<span style="color:#f1fa8c">&#34;I have finished.&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loop <span style="color:#ff79c6">=</span> asyncio<span style="color:#ff79c6">.</span>get_event_loop()
</span></span><span style="display:flex;"><span>fut <span style="color:#ff79c6">=</span> asyncio<span style="color:#ff79c6">.</span>Future()
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">print</span>(fut<span style="color:#ff79c6">.</span>done()) <span style="color:#6272a4"># False </span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loop<span style="color:#ff79c6">.</span>create_task(main(fut))
</span></span><span style="display:flex;"><span>loop<span style="color:#ff79c6">.</span>run_until_complete(fut) <span style="color:#6272a4"># &#34;I have finished.&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">print</span>(fut<span style="color:#ff79c6">.</span>done()) <span style="color:#6272a4"># True </span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">print</span>(fut<span style="color:#ff79c6">.</span>result()) <span style="color:#6272a4"># &#34;I have finished.&#34;</span>
</span></span></code></pre></div><p>In the example above, we created the Future instance <code>fut</code> using <code>asyncio.Future()</code>. By default, this Future instance is <strong>tied to the loop</strong> but is <strong>not (will not be) attached to any coroutine</strong>, as opposed to Task instances. Then, we schedule the <code>main()</code> coroutine, execute the future, the result of the future instance is set when the execution is completed.</p>
<p>From an implementation perspective, a Task inherits from Future - the Future class is a <strong>superclass</strong> that provides primitive building blocks for Tasks. While both represent asynchronous operations, a Future is more generic, representing a <strong>future completion state</strong> of any activity managed by the event loop. A Task is more specific, representing a running coroutine that&rsquo;s been scheduled on the event loop.</p>
<p>This relationship explains why Tasks have all the features of Futures (like the ability to check completion status or retrieve results) plus additional capabilities specific to managing coroutines.</p>
<h4 id="ensure_future-vs-create_task"><code>ensure_future()</code> vs. <code>create_task()</code><a hidden class="anchor" aria-hidden="true" href="#ensure_future-vs-create_task">#</a></h4>
<p>Some developers recommend using <code>asyncio.create_task()</code> to run coroutines while others recommend <code>asyncio.ensure_future()</code>. In summary, <code>asyncio.ensure_future()</code> returns a Task instance when passing in a coroutine; it returns the input unchanged when passing in a Future instance.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff79c6">import</span> asyncio 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">f</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">pass</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>coro <span style="color:#ff79c6">=</span> f()
</span></span><span style="display:flex;"><span>loop <span style="color:#ff79c6">=</span> asyncio<span style="color:#ff79c6">.</span>get_event_loop()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>task <span style="color:#ff79c6">=</span> loop<span style="color:#ff79c6">.</span>create_task(coro)
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">assert</span> <span style="color:#8be9fd;font-style:italic">isinstance</span>(task, asyncio<span style="color:#ff79c6">.</span>Task) <span style="color:#6272a4"># True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>new_task <span style="color:#ff79c6">=</span> asyncio<span style="color:#ff79c6">.</span>ensure_future(coro)
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">assert</span> <span style="color:#8be9fd;font-style:italic">isinstance</span>(new_task, asyncio<span style="color:#ff79c6">.</span>Task) <span style="color:#6272a4"># True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>new_new <span style="color:#ff79c6">=</span> asyncio<span style="color:#ff79c6">.</span>ensure_future(task)
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">assert</span> new_new <span style="color:#ff79c6">is</span> task <span style="color:#6272a4"># True</span>
</span></span></code></pre></div><h2 id="beyond-the-basics-advanced-asyncio-patterns">Beyond the Basics: Advanced AsyncIO Patterns<a hidden class="anchor" aria-hidden="true" href="#beyond-the-basics-advanced-asyncio-patterns">#</a></h2>
<p>As you build more complex asynchronous applications, particularly those interacting with external services like LLM APIs, you&rsquo;ll need more advanced patterns to manage resources and control flow efficiently.</p>
<h2 id="async-context-management-async-with">Async Context Management: <code>async with</code><a hidden class="anchor" aria-hidden="true" href="#async-context-management-async-with">#</a></h2>
<p>Context managers are crucial for properly managing resources in Python, ensuring proper setup and cleanup even when exceptions occur. When working with asynchronous resources - like database connections or API sessions - standard context managers won&rsquo;t suffice because they can block the event loop.</p>
<p>Async context managers solve this problem by providing asynchronous versions of the familiar context management protocol. Instead of <code>__enter__</code> and <code>__exit__</code>, they use <code>__aenter__</code> and <code>__aexit__</code> methods that can be awaited. This allows resources acquisition and release to happen asynchronously without blocking the event loop.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff79c6">class</span> <span style="color:#50fa7b">AsyncDatabase</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> __aenter__(self):
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">await</span> self<span style="color:#ff79c6">.</span>connect() <span style="color:#6272a4"># connect to database object asynchronously </span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> self <span style="color:#6272a4"># returns the database object to be used in the with block</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> __aexit__(self, exc_type, exc, tb): 
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">await</span> self<span style="color:#ff79c6">.</span>disconnect() <span style="color:#6272a4"># disconnect when exiting the with block</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">process_data</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">async</span> <span style="color:#ff79c6">with</span> AsyncDatabase() <span style="color:#ff79c6">as</span> db: <span style="color:#6272a4"># creates database and connects</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">await</span> db<span style="color:#ff79c6">.</span>query(<span style="color:#f1fa8c">&#34;SELECT * FROM data&#34;</span>)
</span></span></code></pre></div><p>The workflow follows a similar pattern to synchronous context managers but with asynchronous operations:</p>
<ol>
<li>when we call <code>async with AsyncDatabase() as db</code>, it creates an <code>AsyncDatabase</code> instance</li>
<li>the event loop awaits the <code>__aenter__</code> method, which connects to the database asynchronously</li>
<li>once connected, the database object is assigned to the variable <code>db</code></li>
<li>within the context block, we can use await and the database&rsquo;s methods (<code>await db.query()</code>)</li>
<li>when the <code>async with</code> block ends (or an exception occurs), the event loop awaits the <code>__aexit__</code> method, ensuring the database disconnects cleanly</li>
</ol>
<p>This pattern is particularly valuable when working with LLM services, as it ensures connections are properly established and released, even if errors occur during processing.</p>
<h3 id="simplifying-context-management-with-decorators">Simplifying Context Management with Decorators<a hidden class="anchor" aria-hidden="true" href="#simplifying-context-management-with-decorators">#</a></h3>
<p>While class-based async context managers offer complete control, they require defining multiple methods and can be verbose. Python provides decorator-based alternatives that are often more concise for simpler cases.</p>
<p>First, let&rsquo;s recall how standard synchronous <code>@contextmanager</code> decorator works for regular context managers:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff79c6">from</span> contextlib <span style="color:#ff79c6">import</span> contextmanager 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># note: download_webpage and update_stats are hypothetical functions</span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># that would typically perform network or file operations</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># use @contextmanager to transform a generator</span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># function into a context manager</span>
</span></span><span style="display:flex;"><span>@contextmanager  
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">def</span> <span style="color:#50fa7b">web_page</span>(url):
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">try</span>:
</span></span><span style="display:flex;"><span>        data <span style="color:#ff79c6">=</span> download_webpage(url) <span style="color:#6272a4"># CPU bound </span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">yield</span> data 
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">except</span> Exception <span style="color:#ff79c6">as</span> e:
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;Error: </span><span style="color:#f1fa8c">{</span><span style="color:#8be9fd;font-style:italic">str</span>(e)<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">finally</span>:
</span></span><span style="display:flex;"><span>        update_stats(url) <span style="color:#6272a4"># CPU bound </span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">with</span> web_page(<span style="color:#f1fa8c">&#34;google.com&#34;</span>) <span style="color:#ff79c6">as</span> data:
</span></span><span style="display:flex;"><span>    process(data) <span style="color:#6272a4"># assume non CPU bound </span>
</span></span></code></pre></div><p>This code above works well for synchronous operations, but would block the event loop if used in an async context. For asynchronous operations, Python provides the <code>@asynccontextmanager</code> decorator, which is analogous to the synchronous version but designed for async functions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff79c6">from</span> contextlib <span style="color:#ff79c6">import</span> asynccontextmanager
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># when using the @asynccontextmanager, the </span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># decorated function needs to be async  </span>
</span></span><span style="display:flex;"><span>@asynccontextmanager  
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">web_page</span>(url):
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">try</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4"># download_webpage() needs to be modified</span>
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4"># to be async as well</span>
</span></span><span style="display:flex;"><span>        data <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">await</span> download_webpage(url) 
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">yield</span> data 
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">except</span> Exception <span style="color:#ff79c6">as</span> e:
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;Error: </span><span style="color:#f1fa8c">{</span><span style="color:#8be9fd;font-style:italic">str</span>(e)<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">finally</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">await</span> update_stats(url)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">with</span> web_page(<span style="color:#f1fa8c">&#34;google.com&#34;</span>) <span style="color:#ff79c6">as</span> data:
</span></span><span style="display:flex;"><span>    process(data) <span style="color:#6272a4"># assume non CPU bound </span>
</span></span></code></pre></div><h3 id="bridging-synchronous-and-asynchronous-worlds">Bridging Synchronous and Asynchronous Worlds<a hidden class="anchor" aria-hidden="true" href="#bridging-synchronous-and-asynchronous-worlds">#</a></h3>
<p>A common challenge when working with LLMs or other external services is integrating existing synchronous libraries into an async application. If you&rsquo;re importing functions like <code>download_webpage()</code> from a third party library that doesn&rsquo;t support async operations, you need to adapt them to work within your async context.</p>
<p>There are two primary approaches to wrap synchronous functions for use in async code:</p>
<ul>
<li>using <code>run_in_executor()</code>:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff79c6">from</span> contextlib <span style="color:#ff79c6">import</span> asynccontextmanager
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> asyncio 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>@asynccontextmanager
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">web_page</span>(url):
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">try</span>: 
</span></span><span style="display:flex;"><span>        loop <span style="color:#ff79c6">=</span> asyncio<span style="color:#ff79c6">.</span>get_event_loop()
</span></span><span style="display:flex;"><span>        data <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">await</span> loop<span style="color:#ff79c6">.</span>run_in_executor(<span style="color:#ff79c6">None</span>, download_webpage, url)
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">yield</span> data 
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">except</span> Exception <span style="color:#ff79c6">as</span> e:
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;Error: </span><span style="color:#f1fa8c">{</span><span style="color:#8be9fd;font-style:italic">str</span>(e)<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">finally</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">await</span> loop<span style="color:#ff79c6">.</span>run_in_executor(<span style="color:#ff79c6">None</span>, update_stats, url)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">with</span> web_page(<span style="color:#f1fa8c">&#34;google.com&#34;</span>) <span style="color:#ff79c6">as</span> data:
</span></span><span style="display:flex;"><span>    process(data)
</span></span></code></pre></div><ul>
<li>using <code>to_thread()</code>:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff79c6">from</span> contextlib <span style="color:#ff79c6">import</span> asynccontextmanager 
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> asyncio 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>@asynccontextmanager
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">web_page</span>(url):
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">try</span>:
</span></span><span style="display:flex;"><span>        data <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">await</span> asyncio<span style="color:#ff79c6">.</span>to_thread(download_webpage, url)
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">yield</span> data 
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">except</span> Exception <span style="color:#ff79c6">as</span> e:
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;Error: </span><span style="color:#f1fa8c">{</span><span style="color:#8be9fd;font-style:italic">str</span>(e)<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">finally</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">await</span> asyncio<span style="color:#ff79c6">.</span>to_thread(update_stats, url)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">with</span> web_page(<span style="color:#f1fa8c">&#34;google.com&#34;</span>) <span style="color:#ff79c6">as</span> data:
</span></span><span style="display:flex;"><span>    process(data)
</span></span></code></pre></div><h2 id="working-with-streams-async-iteration-and-comprehension">Working with Streams: Async Iteration and Comprehension<a hidden class="anchor" aria-hidden="true" href="#working-with-streams-async-iteration-and-comprehension">#</a></h2>
<p>When working with LLMs, you might need to process streaming responses or handle data that arrives incrementally. AsyncIO provides specialized syntax for working with asynchronous iterables - data sources that yield values asynchronously over time.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">process_stream</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">async</span> <span style="color:#ff79c6">for</span> item <span style="color:#ff79c6">in</span> async_stream():
</span></span><span style="display:flex;"><span>        result <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">await</span> process_item(item)
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">yield</span> result
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># Async comprehension</span>
</span></span><span style="display:flex;"><span>results <span style="color:#ff79c6">=</span> [item <span style="color:#ff79c6">async</span> <span style="color:#ff79c6">for</span> item <span style="color:#ff79c6">in</span> process_stream()]
</span></span></code></pre></div><p>Under the hood, async iteration operations similarly to the synchronous versions but with asynchronous methods: when you use <code>async for</code>, Python calls the object&rsquo;s <code>__aiter__</code> method to get an async iterator. Then for each iteration, it awaits the iterator&rsquo;s <code>__anext__</code> method, which returns a value for each iteration and raises <code>StopAsyncIteration</code> when finished.</p>
<p>This pattern is particularly useful when working with streaming LLM responses, where tokens or chunks arrive over time and need to be processed as they become available.</p>
<h2 id="ensuring-reliability-shutdown-gracefully">Ensuring Reliability: Shutdown gracefully<a hidden class="anchor" aria-hidden="true" href="#ensuring-reliability-shutdown-gracefully">#</a></h2>
<p>For LLM applications running as services, proper shutdown handling is critical. When a service terminates abruptly, it might leave resources in an inconsistent sate or drop user requests mid-processing. Implementing graceful shutdown mechanisms ensures your application can terminate cleanly, completing critical operations and releasing resources properly.</p>
<p>When we run Task instances using <code>asyncio.run()</code>, it automatically helps clean up pending tasks in simple scenarios. However, in real-world applications, you may encounter error messages like &ldquo;Task was destroyed but it is pending&rdquo; during shutdown. These typically occur when:</p>
<ul>
<li><code>asyncio.run()</code> exits before all tasks complete</li>
<li>a parent task is cancelled without handling child tasks</li>
<li>the event loop is closed while tasks are still running</li>
<li>background tasks are created but not properly tracked</li>
</ul>
<h3 id="shutdown-strategies-and-best-practices">Shutdown Strategies and Best Practices<a hidden class="anchor" aria-hidden="true" href="#shutdown-strategies-and-best-practices">#</a></h3>
<p>Implementing proper shutdown handling especially important for LLM applications that may be processing user queries or performing resource-intensive operations. Here are key strategies for ensuring graceful shutdown:</p>
<ul>
<li>keep track of all background tasks</li>
<li>use proper signal handlers (for <code>SIGINT</code>/<code>SIGTERM</code>)：
<ul>
<li><code>SIGINT</code> corresponds to <code>KeyboardInterrupt</code></li>
<li><code>SIGTERM</code> is more common in network services, which corresponds to <code>kill</code> in a Unix shell</li>
</ul>
</li>
<li>cancel all tasks during shutdown</li>
<li>wait for cancellations to complete (with timeout)</li>
<li>use <code>try</code>/<code>finally</code> to ensure cleanup runs</li>
<li>avoid creating any tasks inside a cancellation handler</li>
<li>consider using <code>gather(..., return_exceptions=True)</code></li>
</ul>
<p>The example below provides a minimal approach to handling a keyboard interrupt (Ctrl+C):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#6272a4"># a simple example to handle KeyboardInterrupt / Ctrl-C</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> asyncio 
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">from</span> signal <span style="color:#ff79c6">import</span> SIGINT, SIGTERM
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">main</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">while</span> <span style="color:#ff79c6">True</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">&#34;&lt;Your app is running&gt;&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">await</span> asyncio<span style="color:#ff79c6">.</span>sleep(<span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">if</span> __name__ <span style="color:#ff79c6">==</span> <span style="color:#f1fa8c">&#34;__main__&#34;</span>:
</span></span><span style="display:flex;"><span>    loop <span style="color:#ff79c6">=</span> asyncio<span style="color:#ff79c6">.</span>get_event_loop()
</span></span><span style="display:flex;"><span>    task <span style="color:#ff79c6">=</span> loop<span style="color:#ff79c6">.</span>create_task(main())
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">try</span>:
</span></span><span style="display:flex;"><span>        loop<span style="color:#ff79c6">.</span>run_until_complete(task)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">except</span> KeyboardInterrupt:
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">&#34;Got signal: SIGINT, shutting down&#34;</span>) <span style="color:#6272a4"># only Ctrl+C can stop the loop</span>
</span></span><span style="display:flex;"><span>    tasks <span style="color:#ff79c6">=</span> asyncio<span style="color:#ff79c6">.</span>all_tasks(loop<span style="color:#ff79c6">=</span>loop)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> t <span style="color:#ff79c6">in</span> tasks:
</span></span><span style="display:flex;"><span>        t<span style="color:#ff79c6">.</span>cancel()
</span></span><span style="display:flex;"><span>    group <span style="color:#ff79c6">=</span> asyncio<span style="color:#ff79c6">.</span>gather(<span style="color:#ff79c6">*</span>tasks, return_exceptions<span style="color:#ff79c6">=</span><span style="color:#ff79c6">True</span>)
</span></span><span style="display:flex;"><span>    loop<span style="color:#ff79c6">.</span>run_until_complete(group)
</span></span><span style="display:flex;"><span>    loop<span style="color:#ff79c6">.</span>close()
</span></span></code></pre></div><p>However, real-world applications typically need more robust signal handling. For instance, you might want to handle both SIGTERM and SIGINT signals, provide a graceful cleanup period, and ensure your application responds appropriately even when multiple shutdown signals are received in quick succession. The following example builds on the previous one by implementing these more advanced features:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#6272a4"># added feature:</span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># - handling both SIGTERM and SIGINT</span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># - handle CancelledError, and the cleanup code </span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># - handle multiple signals </span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># when hitting Ctrl-C multiple times, the process shuts down when </span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># the main() coroutine eventually completes.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> asyncio 
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">from</span> signal <span style="color:#ff79c6">import</span> SIGINT, SIGTERM
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">main</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">try</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">while</span> <span style="color:#ff79c6">True</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">&#34;&lt;Your app is running&gt;&#34;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">await</span> asyncio<span style="color:#ff79c6">.</span>sleep(<span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">except</span> asyncio<span style="color:#ff79c6">.</span>CancelledError: <span style="color:#6272a4"># a callback handler when a signal is received</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">in</span> <span style="color:#8be9fd;font-style:italic">range</span>(<span style="color:#bd93f9">3</span>): <span style="color:#6272a4"># wait for 3 seconds while the run_until_complete() is running</span>
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">&#34;&lt;Your app is shutting down&gt;&#34;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">await</span> asyncio<span style="color:#ff79c6">.</span>sleep(<span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">def</span> <span style="color:#50fa7b">handler</span>(sig):
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">    Handler to stop the loop, unblock the run_forever,
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">    and allow pending tasks collection and cancellation
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    loop<span style="color:#ff79c6">.</span>stop()
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;Got signal: </span><span style="color:#f1fa8c">{</span>sig<span style="color:#f1fa8c">!s}</span><span style="color:#f1fa8c">, shutting down&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># ignore signals while shutting down</span>
</span></span><span style="display:flex;"><span>    loop<span style="color:#ff79c6">.</span>remove_signal_handler(SIGTERM)
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># disable KeyboardInterrupt / Ctrl-C, </span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># unable to use loop.remove_signal_handler(SIGINT)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># otherwise KeyboardInterrupt / Ctrl-C will be restored </span>
</span></span><span style="display:flex;"><span>    loop<span style="color:#ff79c6">.</span>add_signal_handler(SIGINT, <span style="color:#ff79c6">lambda</span>: <span style="color:#ff79c6">None</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">if</span> __name__ <span style="color:#ff79c6">==</span> <span style="color:#f1fa8c">&#34;__main__:</span>
</span></span><span style="display:flex;"><span>    loop <span style="color:#ff79c6">=</span> asyncio<span style="color:#ff79c6">.</span>get_event_loop()
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> sig <span style="color:#ff79c6">in</span> (SIGTERM, SIGINT):
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4"># setting a signal_handler on SIGINT means KeyboardInterrupt </span>
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4"># will no longer be raised on SIGINT</span>
</span></span><span style="display:flex;"><span>        loop<span style="color:#ff79c6">.</span>add_signal_handler(sig, handler, sig)
</span></span><span style="display:flex;"><span>    task <span style="color:#ff79c6">=</span> loop<span style="color:#ff79c6">.</span>create_task(main())
</span></span><span style="display:flex;"><span>    loop<span style="color:#ff79c6">.</span>run_forever() <span style="color:#6272a4"># only stops when either SIGINT or SIGTERM is sent to the process</span>
</span></span><span style="display:flex;"><span>    tasks <span style="color:#ff79c6">=</span> asyncio<span style="color:#ff79c6">.</span>all_tasks(loop<span style="color:#ff79c6">=</span>loop)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> t <span style="color:#ff79c6">in</span> tasks:
</span></span><span style="display:flex;"><span>        t<span style="color:#ff79c6">.</span>cancel()
</span></span><span style="display:flex;"><span>    group <span style="color:#ff79c6">=</span> asyncio<span style="color:#ff79c6">.</span>gather(<span style="color:#ff79c6">*</span>tasks, return_exceptions<span style="color:#ff79c6">=</span><span style="color:#ff79c6">True</span>)
</span></span><span style="display:flex;"><span>    loop<span style="color:#ff79c6">.</span>run_until_complete(group)
</span></span><span style="display:flex;"><span>    loop<span style="color:#ff79c6">.</span>close()
</span></span></code></pre></div><p>While the previous example works well for many applications, it still uses the older event loop management style. In modern Python (3.7+), we typically use <code>asyncio.run()</code> to manage the event loop. However, this creates a special challenge for signal handling, since asyncio.run() takes control of the event loop creation and management.</p>
<p>The following example shows how to implement robust signal handling in an application using <code>asyncio.run()</code>. Note how we need to adapt our approach to work within the constraints of the higher-level API:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff79c6">import</span> asyncio
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">from</span> signal <span style="color:#ff79c6">import</span> SIGINT, SIGTERM
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">main</span>():
</span></span><span style="display:flex;"><span>    loop <span style="color:#ff79c6">=</span> asyncio<span style="color:#ff79c6">.</span>get_event_loop()
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># because asyncio.run() takes control of the event loop</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># startup, the handlers must be added in the main() func</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> sig <span style="color:#ff79c6">in</span> (SIGINT, SIGTERM):
</span></span><span style="display:flex;"><span>        loop<span style="color:#ff79c6">.</span>add_signal_handler(sig, handler, sig)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">try</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">while</span> <span style="color:#ff79c6">True</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">&#34;&lt;Your app is running&gt;&#34;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">await</span> asyncio<span style="color:#ff79c6">.</span>sleep(<span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">except</span> asyncio<span style="color:#ff79c6">.</span>CancelledError:
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">in</span> <span style="color:#8be9fd;font-style:italic">range</span>(<span style="color:#bd93f9">3</span>):
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">&#34;Your app is shutting down.&#34;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">await</span> asyncio<span style="color:#ff79c6">.</span>sleep(<span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">def</span> <span style="color:#50fa7b">handler</span>(sig):
</span></span><span style="display:flex;"><span>    loop <span style="color:#ff79c6">=</span> asyncio<span style="color:#ff79c6">.</span>get_running_loop()
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># cannot stop the loop using loop.stop()</span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># otherwise will get warning about how the </span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># loop was stopped before the task created </span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># for main() was completed. </span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> task <span style="color:#ff79c6">in</span> asyncio<span style="color:#ff79c6">.</span>all_tasks(loop<span style="color:#ff79c6">=</span>loop):
</span></span><span style="display:flex;"><span>        task<span style="color:#ff79c6">.</span>cancel()
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;Got signal: </span><span style="color:#f1fa8c">{</span>sig<span style="color:#f1fa8c">!s}</span><span style="color:#f1fa8c">, shutting down&#34;</span>)
</span></span><span style="display:flex;"><span>    loop<span style="color:#ff79c6">.</span>remove_signal_handler(SIGTERM)
</span></span><span style="display:flex;"><span>    loop<span style="color:#ff79c6">.</span>add_signal_handler(SIGINT, <span style="color:#ff79c6">lambda</span>: <span style="color:#ff79c6">None</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">if</span> __name__<span style="color:#ff79c6">==</span><span style="color:#f1fa8c">&#34;__main__&#34;</span>:
</span></span><span style="display:flex;"><span>    asyncio<span style="color:#ff79c6">.</span>run(main())
</span></span></code></pre></div><h2 id="advanced-asyncio-modules">Advanced AsyncIO Modules<a hidden class="anchor" aria-hidden="true" href="#advanced-asyncio-modules">#</a></h2>
<p><code>asyncio.gather()</code> allows you to run multiple coroutines concurrently and wait for all of them to complete, returning their results in the same order as the input coroutines</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff79c6">import</span> asyncio
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">fetch_data</span>(url):
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">await</span> asyncio<span style="color:#ff79c6">.</span>sleep(<span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;Data from </span><span style="color:#f1fa8c">{</span>url<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">main</span>():
</span></span><span style="display:flex;"><span>    results <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">await</span> asyncio<span style="color:#ff79c6">.</span>gather(
</span></span><span style="display:flex;"><span>        fetch_data(<span style="color:#f1fa8c">&#34;google.com&#34;</span>),
</span></span><span style="display:flex;"><span>        fetch_data(<span style="color:#f1fa8c">&#34;bing.com&#34;</span>),
</span></span><span style="display:flex;"><span>        return_exceptions<span style="color:#ff79c6">=</span><span style="color:#ff79c6">True</span>
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">print</span>(results)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>asyncio<span style="color:#ff79c6">.</span>run(main())
</span></span></code></pre></div><p><code>asyncio.as_complete()</code> returns an iterator that yields tasks as they complete, regardless of the order they were submitted. This is perfect for scenarios where you want to process results as soon as they&rsquo;re available.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff79c6">import</span> asyncio 
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> random 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">process_item</span>(item):
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">await</span> asyncio<span style="color:#ff79c6">.</span>sleep(random<span style="color:#ff79c6">.</span>uniform(<span style="color:#bd93f9">0.5</span>, <span style="color:#bd93f9">3</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;processed </span><span style="color:#f1fa8c">{</span>item<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">main</span>():
</span></span><span style="display:flex;"><span>    tasks <span style="color:#ff79c6">=</span> [process_item(i) <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">in</span> <span style="color:#8be9fd;font-style:italic">range</span>(<span style="color:#bd93f9">10</span>)]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">for</span> future <span style="color:#ff79c6">in</span> asyncio<span style="color:#ff79c6">.</span>as_completed(tasks):
</span></span><span style="display:flex;"><span>        result <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">await</span> future 
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;got result: </span><span style="color:#f1fa8c">{</span>result<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>asyncio<span style="color:#ff79c6">.</span>run(main())
</span></span></code></pre></div><p><code>asyncio.Semaphore()</code> limit the number of coroutines that can access a resource concurrently. This is crucial when working with APIs that have rate limits or when you need to control resource usage.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff79c6">import</span> asyncio 
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> aiohttp
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">fetch_url</span>(url, session, semaphore):
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">async</span> <span style="color:#ff79c6">with</span> semaphore:
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;fetching </span><span style="color:#f1fa8c">{</span>url<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">async</span> <span style="color:#ff79c6">with</span> session<span style="color:#ff79c6">.</span>get(url) <span style="color:#ff79c6">as</span> response:
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">await</span> response<span style="color:#ff79c6">.</span>text()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">main</span>():
</span></span><span style="display:flex;"><span>    semaphore <span style="color:#ff79c6">=</span> asyncio<span style="color:#ff79c6">.</span>Semaphore(<span style="color:#bd93f9">5</span>)
</span></span><span style="display:flex;"><span>    urls <span style="color:#ff79c6">=</span> [<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;https://example.com/</span><span style="color:#f1fa8c">{</span>i<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">&#34;</span> <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">in</span> <span style="color:#8be9fd;font-style:italic">range</span>(<span style="color:#bd93f9">20</span>)]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">async</span> <span style="color:#ff79c6">with</span> aiohttp<span style="color:#ff79c6">.</span>ClientSession() <span style="color:#ff79c6">as</span> session:
</span></span><span style="display:flex;"><span>        tasks <span style="color:#ff79c6">=</span> [fetch_url(url, session, semaphore) <span style="color:#ff79c6">for</span> url <span style="color:#ff79c6">in</span> urls]
</span></span><span style="display:flex;"><span>        results <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">await</span> asyncio<span style="color:#ff79c6">.</span>gather(<span style="color:#ff79c6">*</span>tasks)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;completed </span><span style="color:#f1fa8c">{</span><span style="color:#8be9fd;font-style:italic">len</span>(results)<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c"> requests&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>asyncio<span style="color:#ff79c6">.</span>run(main())
</span></span></code></pre></div><p><code>asyncio.TaskGroup()</code> provides a cleaner, more structured approach to concurrent task management with automatic cleanup and error propagation.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff79c6">import</span> asyncio 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">process_data</span>(<span style="color:#8be9fd;font-style:italic">id</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">await</span> asyncio<span style="color:#ff79c6">.</span>sleep(<span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;processed data </span><span style="color:#f1fa8c">{</span><span style="color:#8be9fd;font-style:italic">id</span><span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">id</span><span style="color:#ff79c6">*</span><span style="color:#bd93f9">10</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">main</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">async</span> <span style="color:#ff79c6">with</span> asyncio<span style="color:#ff79c6">.</span>TaskGroup() <span style="color:#ff79c6">as</span> tg:
</span></span><span style="display:flex;"><span>        task1 <span style="color:#ff79c6">=</span> tg<span style="color:#ff79c6">.</span>create_task(process_data(<span style="color:#bd93f9">1</span>))
</span></span><span style="display:flex;"><span>        task2 <span style="color:#ff79c6">=</span> tg<span style="color:#ff79c6">.</span>create_task(process_data(<span style="color:#bd93f9">2</span>))
</span></span><span style="display:flex;"><span>        task3 <span style="color:#ff79c6">=</span> tg<span style="color:#ff79c6">.</span>create_task(process_data(<span style="color:#bd93f9">3</span>))
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;results: </span><span style="color:#f1fa8c">{</span>task1<span style="color:#ff79c6">.</span>result()<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">, </span><span style="color:#f1fa8c">{</span>task2<span style="color:#ff79c6">.</span>result()<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">, </span><span style="color:#f1fa8c">{</span>task3<span style="color:#ff79c6">.</span>result()<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>asyncio<span style="color:#ff79c6">.</span>run(main())
</span></span></code></pre></div><h2 id="writing-tests-for-asyncio-code-with-pytest">Writing Tests for AsyncIO Code with pytest<a hidden class="anchor" aria-hidden="true" href="#writing-tests-for-asyncio-code-with-pytest">#</a></h2>
<p>Testing asynchronous code requires special handling. The <code>pytest-asyncio</code> plugin makes this straightforward by providing the <code>pytest.mark.asyncio</code> decorator.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff79c6">import</span> pytest
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> asyncio 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">fetch_data</span>(<span style="color:#8be9fd;font-style:italic">id</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">await</span> asyncio<span style="color:#ff79c6">.</span>sleep(<span style="color:#bd93f9">0.1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;Data for </span><span style="color:#f1fa8c">{</span><span style="color:#8be9fd;font-style:italic">id</span><span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># mark the test as asyncio </span>
</span></span><span style="display:flex;"><span>@pytest.mark.asyncio
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">test_fetch_data</span>():
</span></span><span style="display:flex;"><span>    result <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">await</span> fetch_data(<span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">assert</span> result <span style="color:#ff79c6">==</span> <span style="color:#f1fa8c">&#34;Data for 1&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># testing exceptions </span>
</span></span><span style="display:flex;"><span>@pytest.mark.asyncio 
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">test_fetch_data_with_timeout</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">with</span> pytest<span style="color:#ff79c6">.</span>raises(asyncio<span style="color:#ff79c6">.</span>TimeoutError):
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">await</span> asyncio<span style="color:#ff79c6">.</span>wait_for(asyncio<span style="color:#ff79c6">.</span>sleep(<span style="color:#bd93f9">1</span>), timeout<span style="color:#ff79c6">=</span><span style="color:#bd93f9">0.5</span>)
</span></span></code></pre></div><h3 id="mocking-asynchronous-functions">Mocking Asynchronous Functions<a hidden class="anchor" aria-hidden="true" href="#mocking-asynchronous-functions">#</a></h3>
<p>Testing async code often requires mocking external service. Here&rsquo;s how to do it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff79c6">import</span> pytest
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">from</span> unittest.mock <span style="color:#ff79c6">import</span> AsyncMock, patch 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">get_user_data</span>(client, user_id):
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">await</span> client<span style="color:#ff79c6">.</span>fetch_user(user_id)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>@pytest.mark.asyncio
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">test_get_user_data</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># create a mock client with an async method</span>
</span></span><span style="display:flex;"><span>    mock_client <span style="color:#ff79c6">=</span> AsyncMock()
</span></span><span style="display:flex;"><span>    mock_client<span style="color:#ff79c6">.</span>fetch_user<span style="color:#ff79c6">.</span>return_value <span style="color:#ff79c6">=</span> {<span style="color:#f1fa8c">&#34;id&#34;</span>: <span style="color:#bd93f9">1</span>, <span style="color:#f1fa8c">&#34;name&#34;</span>: <span style="color:#f1fa8c">&#34;Test User&#34;</span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># test our function with the mock client </span>
</span></span><span style="display:flex;"><span>    result <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">await</span> get_user_data(mock_client, <span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># verify the result and that the mock was called correctly</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">assert</span> result <span style="color:#ff79c6">==</span> {<span style="color:#f1fa8c">&#34;id&#34;</span>: <span style="color:#bd93f9">1</span>, <span style="color:#f1fa8c">&#34;name&#34;</span>: <span style="color:#f1fa8c">&#34;Test User&#34;</span>}
</span></span><span style="display:flex;"><span>    mock_client<span style="color:#ff79c6">.</span>fetch_user<span style="color:#ff79c6">.</span>assert_called_once_with(<span style="color:#bd93f9">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>@pytest.mark.asyncio
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">test_with_patch</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">with</span> patch(<span style="color:#f1fa8c">&#34;module_name.api_client&#34;</span>) <span style="color:#ff79c6">as</span> mock_client:
</span></span><span style="display:flex;"><span>        mock_client<span style="color:#ff79c6">.</span>fetch_data <span style="color:#ff79c6">=</span> AsyncMock(return_value<span style="color:#ff79c6">=</span><span style="color:#f1fa8c">&#34;mocked data&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#6272a4"># ...</span>
</span></span></code></pre></div><h3 id="test-asynchronous-context-managers">Test Asynchronous Context Managers<a hidden class="anchor" aria-hidden="true" href="#test-asynchronous-context-managers">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff79c6">import</span> pytest
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">from</span> unittest.mock <span style="color:#ff79c6">import</span> AsyncMock 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>@pytest.mark.asyncio 
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">test_async_context_manager</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># create a mock for an async context manager </span>
</span></span><span style="display:flex;"><span>    mock_db <span style="color:#ff79c6">=</span> AsyncMock()
</span></span><span style="display:flex;"><span>    mock_db<span style="color:#ff79c6">.</span>__aenter__<span style="color:#ff79c6">.</span>return_value <span style="color:#ff79c6">=</span> mock_db 
</span></span><span style="display:flex;"><span>    mock_db<span style="color:#ff79c6">.</span>query<span style="color:#ff79c6">.</span>return_value <span style="color:#ff79c6">=</span> [<span style="color:#f1fa8c">&#34;result1&#34;</span>, <span style="color:#f1fa8c">&#34;result2&#34;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># use the mock in an async with statement </span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">async</span> <span style="color:#ff79c6">with</span> mock_db <span style="color:#ff79c6">as</span> db:
</span></span><span style="display:flex;"><span>        result <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">await</span> db<span style="color:#ff79c6">.</span>query(<span style="color:#f1fa8c">&#34;SELECT * FROM TABLE&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># verify results</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">assert</span> result <span style="color:#ff79c6">==</span> [<span style="color:#f1fa8c">&#34;result1&#34;</span>, <span style="color:#f1fa8c">&#34;result2&#34;</span>]
</span></span><span style="display:flex;"><span>    mock_db<span style="color:#ff79c6">.</span>query<span style="color:#ff79c6">.</span>assert_called_once_with(<span style="color:#f1fa8c">&#34;SELECT * FROM TABLE&#34;</span>)
</span></span><span style="display:flex;"><span>    mock_db<span style="color:#ff79c6">.</span>__aexit__<span style="color:#ff79c6">.</span>assert_called_once()
</span></span></code></pre></div><h2 id="ecosystem-integrations">Ecosystem Integrations<a hidden class="anchor" aria-hidden="true" href="#ecosystem-integrations">#</a></h2>
<h2 id="working-with-http-requests-aiohttp">Working with HTTP Requests: <code>aiohttp</code><a hidden class="anchor" aria-hidden="true" href="#working-with-http-requests-aiohttp">#</a></h2>
<p><code>aiohttp</code> is an asynchronous HTTP client/server framework built on top of asyncio, perfect for making non-blocking HTTP requests. Its key features include:</p>
<ul>
<li>reuses connections from a ClientSession pool</li>
<li>supports streaming responses</li>
<li>handles cookies, headers and authentication</li>
<li>provides both client and server implementation</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff79c6">import</span> asyncio 
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> aiohttp 
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> time 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">fetch_url</span>(session, url):
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">async</span> <span style="color:#ff79c6">with</span> session<span style="color:#ff79c6">.</span>get(url) <span style="color:#ff79c6">as</span> response:
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">await</span> response<span style="color:#ff79c6">.</span>text()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">fetch_all</span>(urls):
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">async</span> <span style="color:#ff79c6">with</span> aiohttp<span style="color:#ff79c6">.</span>ClientSession() <span style="color:#ff79c6">as</span> session:
</span></span><span style="display:flex;"><span>        tasks <span style="color:#ff79c6">=</span> [fetch_url(session, url) <span style="color:#ff79c6">for</span> url <span style="color:#ff79c6">in</span> urls]
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">await</span> asyncio<span style="color:#ff79c6">.</span>gather(<span style="color:#ff79c6">*</span>tasks)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">main</span>():
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    urls <span style="color:#ff79c6">=</span> [
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;https://example.com&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;https://python.org&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;https://docs.python.org&#34;</span>
</span></span><span style="display:flex;"><span>    ]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    start <span style="color:#ff79c6">=</span> time<span style="color:#ff79c6">.</span>perf_counter()
</span></span><span style="display:flex;"><span>    results <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">await</span> fetch_all(urls)
</span></span><span style="display:flex;"><span>    end <span style="color:#ff79c6">=</span> time<span style="color:#ff79c6">.</span>perf_counter()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;Fetched </span><span style="color:#f1fa8c">{</span><span style="color:#8be9fd;font-style:italic">len</span>(results)<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c"> sites in </span><span style="color:#f1fa8c">{</span>end<span style="color:#ff79c6">-</span>start<span style="color:#f1fa8c">:</span><span style="color:#f1fa8c">.2f</span><span style="color:#f1fa8c">}</span><span style="color:#f1fa8c"> seconds&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">print</span>(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;First 100 chars of each: </span><span style="color:#f1fa8c">{</span>[r[:<span style="color:#bd93f9">100</span>] <span style="color:#ff79c6">for</span> r <span style="color:#ff79c6">in</span> results]<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>asyncio<span style="color:#ff79c6">.</span>run(main())
</span></span></code></pre></div><h2 id="asynchronous-file-operations-aiofiles">Asynchronous File Operations: <code>aiofiles</code><a hidden class="anchor" aria-hidden="true" href="#asynchronous-file-operations-aiofiles">#</a></h2>
<p><code>aiofiles</code> provides asynchronous file I/O operations, allowing file operations to run without blocking the event loop. It is particularly useful when writing/reading large files, processing multiple files concurrently, working with files while maintaining UI responsiveness, and integrating file operations with other async I/O operations.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff79c6">import</span> asyncio
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> aiofiles
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">read_large_file</span>(filename):
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">async</span> <span style="color:#ff79c6">with</span> aiofiles<span style="color:#ff79c6">.</span>open(filename, <span style="color:#f1fa8c">&#39;r&#39;</span>) <span style="color:#ff79c6">as</span> file:
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">await</span> file<span style="color:#ff79c6">.</span>read()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">write_data</span>(filename, data):
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">async</span> <span style="color:#ff79c6">with</span> aiofiles<span style="color:#ff79c6">.</span>open(filename, <span style="color:#f1fa8c">&#39;w&#39;</span>) <span style="color:#ff79c6">as</span> file:
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">await</span> file<span style="color:#ff79c6">.</span>write(data)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">process_files</span>(filenames):
</span></span><span style="display:flex;"><span>    tasks <span style="color:#ff79c6">=</span> [read_large_file(filename) <span style="color:#ff79c6">for</span> filename <span style="color:#ff79c6">in</span> filenames]
</span></span><span style="display:flex;"><span>    contents <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">await</span> asyncio<span style="color:#ff79c6">.</span>gather(<span style="color:#ff79c6">*</span>tasks)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># Process contents...</span>
</span></span><span style="display:flex;"><span>    results <span style="color:#ff79c6">=</span> [content<span style="color:#ff79c6">.</span>upper() <span style="color:#ff79c6">for</span> content <span style="color:#ff79c6">in</span> contents]<span style="color:#ff79c6">****</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4"># Write results</span>
</span></span><span style="display:flex;"><span>    write_tasks <span style="color:#ff79c6">=</span> [
</span></span><span style="display:flex;"><span>        write_data(<span style="color:#f1fa8c">f</span><span style="color:#f1fa8c">&#34;processed_</span><span style="color:#f1fa8c">{</span>filename<span style="color:#f1fa8c">}</span><span style="color:#f1fa8c">&#34;</span>, result) 
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">for</span> filename, result <span style="color:#ff79c6">in</span> <span style="color:#8be9fd;font-style:italic">zip</span>(filenames, results)
</span></span><span style="display:flex;"><span>    ]
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">await</span> asyncio<span style="color:#ff79c6">.</span>gather(<span style="color:#ff79c6">*</span>write_tasks)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">def</span> <span style="color:#50fa7b">main</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">await</span> process_files([<span style="color:#f1fa8c">&#39;file1.txt&#39;</span>, <span style="color:#f1fa8c">&#39;file2.txt&#39;</span>, <span style="color:#f1fa8c">&#39;file3.txt&#39;</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>asyncio<span style="color:#ff79c6">.</span>run(main())
</span></span></code></pre></div><h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>AsyncIO has transformed Python&rsquo;s approach to handling I/O-bound operations, offering a simple yet powerful approach to concurrency without the complexity of traditional multithreading. Its core advantages - improved responsiveness, maximized resource utilization, and elegant syntax - make it particularly well-suited for AI application development. The extensive AsyncIO ecosystem, with libraries for HTTP requests, file operations, and database access, extends these capabilities across all I/O domains. As AI services continue to expand in importance and complexity, AsyncIO&rsquo;s role will only grow, becoming a fundamental pattern for developers building responsive, scalable applications in an increasingly API-driven landscape.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/python/">Python</a></li>
      <li><a href="http://localhost:1313/tags/concurrency/">Concurrency</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="http://localhost:1313/posts/dspy/">
    <span class="title">Next »</span>
    <br>
    <span>Understanding DSPy</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Asyncio in Python on x"
            href="https://x.com/intent/tweet/?text=Asyncio%20in%20Python&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fasyncio%2f&amp;hashtags=python%2cconcurrency">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Asyncio in Python on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fasyncio%2f&amp;title=Asyncio%20in%20Python&amp;summary=Asyncio%20in%20Python&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fasyncio%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Asyncio in Python on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fasyncio%2f&title=Asyncio%20in%20Python">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Asyncio in Python on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fasyncio%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Asyncio in Python on whatsapp"
            href="https://api.whatsapp.com/send?text=Asyncio%20in%20Python%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fasyncio%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Asyncio in Python on telegram"
            href="https://telegram.me/share/url?text=Asyncio%20in%20Python&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fasyncio%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Asyncio in Python on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Asyncio%20in%20Python&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fasyncio%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">De Omnibus Dubitandum</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
